<?php
/**
 * Encryption helpers for protecting sensitive configuration data.
 *
 * Uses AES-256-GCM via OpenSSL. Keys are sourced from:
 *  1. Environment variable ABBIS_ENCRYPTION_KEY (base64 or hex encoded)
 *  2. Fallback file config/secrets/encryption.key (raw bytes or encoded)
 *
 * Key management guidance:
 *  - Rotate keys periodically; maintain previous keys to decrypt historical data.
 *  - Store keys outside of version control (environment or secure secret store).
 *  - Restrict read access to key files and environment variables.
 */

class Crypto
{
    private const CIPHER = 'aes-256-gcm';
    private const PREFIX = 'ENC:v1:';
    private const TAG_LENGTH = 16;

    private static ?string $encryptionKey = null;

    /**
     * Encrypt a plaintext string. Returns an encoded payload with prefix.
     */
    public static function encrypt(?string $plaintext): ?string
    {
        if ($plaintext === null || $plaintext === '') {
            return $plaintext;
        }

        $key = self::getKey();
        $iv = random_bytes(12);
        $tag = '';

        $ciphertext = openssl_encrypt(
            $plaintext,
            self::CIPHER,
            $key,
            OPENSSL_RAW_DATA,
            $iv,
            $tag,
            '',
            self::TAG_LENGTH
        );

        if ($ciphertext === false) {
            throw new RuntimeException('Failed to encrypt data with OpenSSL.');
        }

        $payload = base64_encode($iv . $tag . $ciphertext);
        return self::PREFIX . $payload;
    }

    /**
     * Decrypt an encoded payload generated by encrypt().
     */
    public static function decrypt(?string $payload): ?string
    {
        if ($payload === null || $payload === '') {
            return $payload;
        }

        if (!self::isEncrypted($payload)) {
            return $payload;
        }

        $encoded = substr($payload, strlen(self::PREFIX));
        $decoded = base64_decode($encoded, true);
        if ($decoded === false || strlen($decoded) <= (12 + self::TAG_LENGTH)) {
            throw new RuntimeException('Invalid encrypted payload.');
        }

        $iv = substr($decoded, 0, 12);
        $tag = substr($decoded, 12, self::TAG_LENGTH);
        $ciphertext = substr($decoded, 12 + self::TAG_LENGTH);

        $plaintext = openssl_decrypt(
            $ciphertext,
            self::CIPHER,
            self::getKey(),
            OPENSSL_RAW_DATA,
            $iv,
            $tag
        );

        if ($plaintext === false) {
            throw new RuntimeException('Failed to decrypt payload.');
        }

        return $plaintext;
    }

    /**
     * Determine whether the value was encrypted by this helper.
     */
    public static function isEncrypted(?string $value): bool
    {
        return is_string($value) && str_starts_with($value, self::PREFIX);
    }

    /**
     * Load and cache the encryption key.
     */
    private static function getKey(): string
    {
        if (self::$encryptionKey !== null) {
            return self::$encryptionKey;
        }

        $key = getenv('ABBIS_ENCRYPTION_KEY');
        if (!$key) {
            $keyPath = __DIR__ . '/../config/secrets/encryption.key';
            if (is_readable($keyPath)) {
                $key = trim(file_get_contents($keyPath));
            }
        }

        if (!$key) {
            throw new RuntimeException('Encryption key not configured. Set ABBIS_ENCRYPTION_KEY or provide config/secrets/encryption.key');
        }

        $decoded = self::decodeKey($key);
        if (strlen($decoded) !== 32) {
            throw new RuntimeException('Encryption key must be 32 bytes (provide 32 raw bytes or base64/hex encoded string).');
        }

        self::$encryptionKey = $decoded;
        return self::$encryptionKey;
    }

    /**
     * Decode key material from base64/hex/raw string.
     */
    private static function decodeKey(string $key): string
    {
        $key = trim($key);

        // Base64 detection
        $base64 = base64_decode($key, true);
        if ($base64 !== false && base64_encode($base64) === $key) {
            return $base64;
        }

        // Hex detection
        if (ctype_xdigit($key) && strlen($key) % 2 === 0) {
            return hex2bin($key);
        }

        // Assume raw bytes
        return $key;
    }
}

